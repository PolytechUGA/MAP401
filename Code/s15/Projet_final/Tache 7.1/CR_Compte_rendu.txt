
Tâche 1 : Module Image
    Cette tâche nous à permis de nous familiariser avec les différents modules mis à notre disposition
    tel quel le module image. Dans cette tâche, nous avons créer un module image dans lequel on trouve 
    des fonctions permettant de calculer le négatif d’une image ainsi que d’écrire une image dans le terminal. 
    Pour écrire une image, on parcours chaque pixels. Si le pixels est noir, on affiche un « X » et sinon,
    le pixel est alors blanc. Dans ce cas, on affiche un espace. Pour la négation de l’image, on parcours 
    chaque pixels. Si le pixels est noir, on le remplace par un 
    pixel blanc. Sinon, on fait l’inverse. 

    Nous avons aussi créer un programme de test pour ce module image nommé test_image. 
    Il se lance grâce à la commande ./test_image image.pbm (où l’image.pbm représente 
    l’image que l’on veut tester). Ce programme prend une image en paramètre et permet de vérifier 
    si les fonctions du module image fonctionnent correctement.


Tâche 2 : Module Geom2d

    Pour réaliser cette tâche, nous avons créer un module geom2d qui permet la gestion de la géométrie. 
    Ce module contient la définition des types Points et Vecteur ainsi que plusieurs fonctions permettant 
    la gestion de ces éléments. Ces fonctions permettent d’effectuer des opérations avec ces deux types : 
    Somme des vecteurs et des points, produit entre vecteurs et points, produit scalaire, la norme, 
    la distance…

    Nous avons aussi créer un programme de test pour ce module geom2d nommé ./test_geom. Il permet de  
    tester les fonctions set_point, add_point, produit entre réel et points ou entre réels et vecteurs, 
    vect_bipoint, norme_vecteur, distance_entre_points, produit_scalaire…


Tâche 3 : Extraction de Contour

    Pour cette tâche, nous avons créer un module calcul_contour qui permet la gestion des 
    déplacements du robot sur l’image, la détection des pixels candidats pour le calcul du 
    contour, la création et la gestion de l’Image de Masque ainsi que le stockage de ce contour 
    dans une liste. Création module ecriture_contours pour gérer l'écriture des contours passé en
    argument dans un fichier ou dans le terminal passé en argument Nous avons mis au point un module
    pour gérer les listes chainees de points.

    Pour tester cette tâche, nous avons implémenter un programme test_contour qui prend en 
    argument une image et un fichier de sortie. Ce programme permet de calculer les contours de 
    l’image entrée en argument et d’écrire le contour dans un fichier donné en second argument.

Tâche 4 : Sortie au format PostScript encapsulé

    Dans cette tâche, il est question de créer un programme qui va mettre l'image sous forme 
    EPS (Encapsulated PostScript), pour pouvoir l'afficher avec la commande gv. Pour cela, nous 
    avons créer un module sortie_EPS qui nous permet de gérer toutes les fontions relatives aux format EPS.
    

    Pour tester notre programme, nous avons créé test_EPS qui prend en argument une image en .pbm
    et un fichier de sortie et écrit dedans l'image sous forme EPS. L'éxecutable affiche aussi le
    nombre de segment de l'image. 

Tâche 5 : Extraction des contours d'une image
    
    Pour répondre à la question de la tâche 5, nous avons mis à jour les modules calcul_contour et 
    sortie_EPS pour permettre de mettre  dans une liste de contours tout les contours d'une image 
    et de gérer l'affichage dans un fichier, dans un terminal et la sortie EPS.

    L'executable de la tâche 5 est ecrire_liste_contours. Il permet d'écrire dans un fichier une 
    image en format EPS à partir de la liste des contours d'une image. Pour la tâche 5.1 on l'appelle 
    avec 2 arguments. On affiche alors dans le fichier passé en argument les coordonnées de tout les
    points composants le contour. En entrant 3 arguments, on choisit de lancer l'executable de la Tâche 5.2 et
    ainsi d'écrire dans le fichier une image en format EPS.

Tâche 6 : Simplification de contour par segment
    Tâche 6.1:
        Pour cette tâche, nous avons mis à jour le module geom2d pour y intégrer une fonction distance_point_segment
        qui calcule la distance entre un point (donné en argument) et un segment dont les deux extrémités sont données 
        en paramètre.

        L'exécutable est distance_pts_seg.c et permet à l'utilisateur d'entrer les coordonnées de 3 points pour calculer
        la distance entre le premier et le segment formé par les deux autres.
    Tâche 6.2:
        Pour cette tâche nous avons codé le module Douglas_Peucker qui comporte l'algorithme du même nom. Nous avons créer le module
        liste_chainees_contours, qui gère les listes chainees de contours. La fonction douglas peucker recoit une liste 
        de points, deux entiers j1 et j2 ainsi que la distance max entre un point et un segement. Elle renvoie une liste de 
        points, correspondant à l'image simplifiée.

        Dans cette tâche l'éxecutable a pour sobriquet simplification_par_segment et recoit en argument une image ".pbm",
        la distance seuil d, le mode d'affichage (fill ou stroke représentés par 0 ou 1) et un fichier de sortie ".EPS".
        Ensuite avec la commande gv on peut visualiser l'image créée par le programme.
    
Tâche 7 : Simplification de contour par courbe de Bézier
    Tâche 7.1 : Simplification par courbe de degré 2
        Dans cette tâche nous avons mis au point les modules liste_contour_bezier et listes_chainees_bezier. Le premier
        permettant de gérer des listes de listes de courbe de degré 3, et le deuxième permettant de gérer des listes 
        de courbes de Bézier de degré 3. On a aussi créé le module courbe_bezier qui définie les types Bézier 2, Bézier 3
        et comporte une fonction pour calculer un point d'une courbe de degré 2, une pour convertir une courbe de degré 2 en courbe
        de degré 3, une fonction d’approximation d’une courbe de Bézier 2 à partir de 2 points ou plus et une fonction
        renvoyant la distance entre un point et une courbe de Bézier de degré 2. Le module Douglas_Peucker a été amélioré
        pour pouvoir acceuillir une nouvelle version de l'algorithme alias simplification_douglas_peucker_bezier2 qui prends
        un tableau de point, deux entiers j1 et j2, et la distance seuil d et renvoie une liste de Bézier 3 c'est à dire le contour 
        simplifié par courbe de Bézier de degré 2. A noter que avant d'être ajouter à la liste chainée de Bézier 3,
        la courbe est convertie en courbe de degré 3 car le format EPS ne prend en charge que des courbes de Bézier de degré 3.
        Le module sortie_EPS se trouve élargie et voit arriver la fonction ecriture_fichier_EPS_bezier3 qui est une revisite
        de sa grande soeur apercue tantôt dans la tâche 5. Elle recoit une liste de contourde courbes de Bézier de degré 3 et
        écrit dans un fichier de sortie en ".EPS" les courbes de Bézier avec l'instruction "curveto" au lieu de "lineto".

        L'éxecutable de cette tâche se nomme simplification_par_bezier2. Il a besoin en argument d'une image ".pbm",
        d'une distance seuil d, du mode d'affichage (0=strocke ou 1=fill) et d'un fichier de sortie en ".EPS". 
        On applique la fonction simplification_douglas_peucker_bezier2 à chaque contour de l'image et le programme
        écrit l'image simplifiée dans le fichier de sortie. 
    Tâche 7.2 : Simplification par courbe de degré 3
        Pour cette tâche nous reprenons la tâche 7.1 mais en adaptant les types et fonctions pour que le programme
        simplifie non plus par courbe de Bézier de degré 2, mais par courbe de Bézier de degré 3. Douglas_Peucker
        a été remis au goût du jour grâce à l'implémentation de la fonction simplification_douglas_peucker_bezier3
        qui construit directement des courbes de degré 3 avec approx_bezier3. Naturellement il devient inutile de
        convertir la courbe, cette ligne n'est donc plus présente dans la fonction. Nous avons mis à jour le module
        courbe_bezier pour y ajouter une fonction de calcul d'un point d'une courbe de Bézier de degré 3, une
        fonction d'approximation de Bézier 3 citée plus haut approx_bezier3 qui recoit un tableau de point et deux entiers
        j1 et j2 et renvoie une Bézier de degré 3. La fonction distance_point_bezier2 est reprise et adapté pour devenir
        distance_point_bezier3.

        Son éxecutable est simplification_par_bezier3. Il a besoin en argument d'une image ".pbm", de la distance seuil d,
        du mode et du fichier de sortie ".EPS". Le programme écrit ensuite l'image simplifiée en courbe de bézier de degré 3
        en fonction de la distance seuil dans le fichier de sortie. L'utilisateur peut alors la visualiser grâce à la commande
        gv.
        
Tâche 8: Optimiation




A la suite de ces tests, nous remarquons que plus la distance seuil augmente, plus le nombre de 
segments et ne nombre de courbes de Bézier diminue. Cette observation est cohérente car un image
simplifier doit contenir moins de détails et par conséquent, n'as pas besoin d'autant de segments
et de courbes qu'une image plus détaillée.
De plus, on remarque que les simplifications entre les distances ... et les distances ... n'opèrent pas de 
changement majeurs visibles à l'oeil nu. 
Il est donc cohérent d'utiliser une distance de simplification de ... afin de préserver l'aspect visuel 
de l'image tout en diminuant l'espace prise par cette image.

Enfin, nous remarquons que la simplification par segments est assez grossière et dégrade la qualitée de
l'image très rapidement. Lorsqu'on utilise des courbes de bézier, cette dégradation de la qualitée d'image 
est moins grande ce qui nous permet de simplifier plus les images.
On remarque aussi que les courbes de Bezier de degrès 3 permettent d'obtenir un image simplifier 
de meilleure qualitée, qui ressemble plus à celle initial, par rapport à une courbe de bézier de degrès 2.
